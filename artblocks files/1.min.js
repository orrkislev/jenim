async function drawDot(t){allDots++,allDots%2e4==0&&await timeout(0),point(t.x,t.y)}function timeout(t){return new Promise(e=>setTimeout(e,t))}async function burn(t,e,i=7){blendMode(BURN),fill(30,30,90,i),noStroke(),circle(t.x,t.y,e*R.random(.4,1)),blendMode(BLEND)}function getPointOnEllipse(t,e,i){return createVector(.5*t*cos(i),.5*e*sin(i))}function getEllipse(t,e,i=1,r=0,a=360){const s=[];for(let o=r;o<a;o+=i)s.push(getPointOnEllipse(t,e,o));return s}function toCrv(t){t.push(t[t.length-1]),t.splice(0,0,t[0]);const e=[];for(let i=0;i<t.length-3;i++){const r=t[i+1],a=t[i+2],s=p5.Vector.dist(r,a);for(let r=0;r<s;r++)x=curvePoint(t[i].x,t[i+1].x,t[i+2].x,t[i+3].x,r/s),y=curvePoint(t[i].y,t[i+1].y,t[i+2].y,t[i+3].y,r/s),e.push(createVector(x,y))}return e}function crvLength(t){l=0;for(let e=0;e<t.length-1;e++)l+=p5.Vector.dist(t[e],t[e+1]);return l}function placeOnCurve(t,e){let i=0;for(let r=0;r<t.length-1;r++)if(i+=sqrt((t[r].x-t[r+1].x)**2+(t[r].y-t[r+1].y)**2),i>=e)return t[r];return!1}function initDenimParams(){warpSpacingMinMax=[.8,2],weftSpacingMinMax=[.8,1],startOffset=[2,1,0],patternTop=[2],patternBottom=[1],specialWeave=!1,R.random_dec()<.07&&(specialWeave=!0,startOffset=Array(R.random_int(1,3)).fill(0).map((t,e)=>e),patternTop=Array(R.random_int(1,3)).fill(0).map(t=>R.random_int(1,3)),patternBottom=Array(R.random_int(1,3)).fill(0).map(t=>R.random_int(1,3)))}class Random{constructor(){this.usage=0,this.useA=!1;let t=function(t){let e=parseInt(t.substr(0,8),16),i=parseInt(t.substr(8,8),16),r=parseInt(t.substr(16,8),16),a=parseInt(t.substr(24,8),16);return function(){e|=0,i|=0,r|=0,a|=0;let t=(e+i|0)+a|0;return a=a+1|0,e=i^i>>>9,i=r+(r<<3)|0,r=r<<21|r>>>11,r=r+t|0,(t>>>0)/4294967296}};this.prngA=new t(tokenData.hash.substr(2,32)),this.prngB=new t(tokenData.hash.substr(34,32));for(let t=0;t<1e6;t+=2)this.prngA(),this.prngB()}random_dec(){return this.usage++,this.useA=!this.useA,this.useA?this.prngA():this.prngB()}random_num(t,e){return t+(e-t)*this.random_dec()}random_int(t,e){return Math.floor(this.random_num(t,e+1))}random_choice(t){return t[this.random_int(0,t.length-1)]}random(t=1,e=0){return this.random_num(t,e)}random_in(t){return this.random_num(t[0],t[1])}}let R=new Random;p5.Color.prototype.toRGB=function(){return color(red(this),green(this),blue(this),alpha(this))},Array.prototype.rotate=function(){return this.push(this.shift()),this[0]};const v=(t,e)=>createVector(t,e),v_rel=(t,e)=>createVector(t*baseWidth,e*baseHeight),vlerp=p5.Vector.lerp,vdist=p5.Vector.dist;vadd=p5.Vector.add,vsub=p5.Vector.sub;let allDots=0;class Denim{constructor(t,e,i=.5){this.lp=t,this.color=e,this.visibleWhite=R.random(.5,1),this.darkness=R.random(.3),this.noiseScale=R.random(200,400),this.warpExtensions=[15,40],this.extendChance=.5,this.age=i,this.rotation=0,this.ripNoiseZ=R.random(1e3),this.ripThreshold=R.random(.18,.32),this.ripMin=R.random(30,70)*initialThreadSize,this.ripMax=R.random(this.ripMin,160)*initialThreadSize,this.ripExtendMasks=[]}rotate(t){return this.rotation=t,this}calc(){return this.ripThreshold+=.3*globalAge,this.age+=globalAge,this.ripMin-=30*globalAge,this.ripMax-=70*globalAge,this.warp||this.makeWarp(),this.weft||this.makeWeft(),this.trim(),this.unravel(),this.doAge(),this}async draw(t={}){threadSize=initialThreadSize,await this.drawWarp(),await this.drawWeft(),t.dontFringe||await this.extendWarps(),await this.lp.drawStitches(this)}async finishDraw(){this.hasRips&&await this.drawRips()}makeWarp(){const t=this.lp.rotatedContainingSquare(this.rotation),{pos:e,w:i,h:r,rotation:a}=t.getDimension(),s=p5.Vector.fromAngle(radians(a)).setMag(i),o=s.copy().rotate(PI/2).normalize(),n=5*initialThreadSize,h=e.copy().add(o.copy().setMag(n).mult(-1)),l=h.copy().add(s).add(),p=15,c=Array(p).fill(0).map((t,e)=>vlerp(h,l,e/(p-1)));c.forEach(t=>t.add(o.copy().mult(R.random(-n,n)))),this.warp=[c];let d=!0;for(;d;){const t=this.warp[this.warp.length-1],e=t.map(t=>t.copy());e.forEach(t=>t.add(o.copy().mult(threadSize*R.random(warpSpacingMinMax[0],warpSpacingMinMax[1])))),this.warp.push(e),d=!1,e.forEach((t,e)=>{vdist(t,c[e])<r&&(d=!0)})}this.warp=this.warp.map(t=>toCrv(t))}async drawWarp(){let t=0;threadSize=initialThreadSize/2;for(const e of this.warp){const i=lerpColor(color(warpColors[0]),color(warpColors[1]),R.random_dec());await thread(e,i,2),t++%10==0&&await timeout(0)}}async extendWarps(){for(const t of this.warp){if(R.random_dec()<this.extendChance){const e=vsub(t[0],t[1]);await franzim(t[0],e,threadSize*R.random_in(this.warpExtensions))}if(R.random_dec()<this.extendChance){const e=vsub(t[t.length-1],t[t.length-2]);await franzim(t[t.length-1],e,threadSize*R.random_in(this.warpExtensions))}await timeout(0)}}makeWeft(){threadSize=initialThreadSize,this.weft=[{column:this.warp.map(t=>t[0]),threadSize:threadSize}];const t=crvLength(this.warp.reduce((t,e)=>crvLength(t)>crvLength(e)?t:e));for(let e=0;e<t;e+=threadSize*R.random_in(weftSpacingMinMax))this.weft.push({column:this.warp.map(t=>placeOnCurve(t,e)).filter(t=>0!=t),threadSize:threadSize}),threadSize=initialThreadSize*R.random(1,1.2);const e=color(this.color),i=lerpColor(e,color(255),this.visibleWhite);this.weft=this.weft.map(t=>{const r=[],a=[e,i];for(let t=0;t<startOffset[0]-1;t++)a.rotate();for(let e=startOffset.rotate();e<t.column.length;e+=patternBottom.rotate()){let i=t.column.slice(e,e+patternTop.rotate()+1);e+=patternTop[0];let s=a.rotate();s=lerpColor(s,color(0),noise(i[0].x/this.noiseScale,i[0].y/this.noiseScale)*this.darkness),r.push(new Loop(i,s,t.threadSize))}return r})}async drawWeft(){let t=0;for(const e of this.weft){for(const t of e)await t.draw();t++%10==0&&await timeout(0)}}hasWeftOn(t){for(const e of this.weft)for(const i of e)for(const e of i.ps)if(e&&vdist(t,e)<5)return i;return!1}trim(){this.warp=this.warp.map(t=>t.filter(t=>this.lp.pointInPattern(t))),this.warp=this.warp.filter(t=>t.length>1),this.weft=this.weft.map(t=>t.filter(t=>t.ps.filter(t=>this.lp.pointInPattern(t)).length>1)),this.warp=this.warp.map(t=>t.filter(t=>t.x>=.1*-baseWidth&&t.x<=1.1*baseWidth&&t.y>=.1*-baseHeight&&t.y<=1.1*baseHeight))}unravel(){this.weft.forEach(t=>{t.length>4&&(t[0].ps.forEach(t=>t.add(threadSize*R.random(-.3,.3),threadSize*R.random(-.3,.3))),t[t.length-1].ps.forEach(t=>t.add(threadSize*R.random(-.3,.3),threadSize*R.random(-.3,.3))))})}pointInRip(t){return noise(ripNoiseScale[0]*t.x/baseWidth,ripNoiseScale[1]*t.y/baseHeight,this.ripNoiseZ)<this.ripThreshold}makeRips(){this.warpRips=[],this.weftRips=[];for(let t=0;t<this.warp.length;t++){const e=this.warp[t];let i=[];if(0!=e.length)for(let t=0;t<200;t++){const r=e[floor(e.length*t/200)];if(this.pointInRip(r))i.push(t);else{if(i.length>2){const t=i.map(t=>floor(t*e.length/200)),r=t.map(t=>e[t]),a=crvLength(r),s=r[0].copy(),o=r[1].copy(),n=r[r.length-1].copy(),h=r[r.length-2].copy();if(a>this.ripMin&&a<this.ripMax){let i=[];for(let t=0;t<=5;t++)i.push(vlerp(s,n,t/5).add(0,R.random(-2,4)));i=toCrv(i),e.splice(t[0],t[t.length-1]-t[0],...i)}a>this.ripMax&&(this.warpRips.push({pos:s,dir:vsub(o,s),len:a*R.random(.1,.5)}),this.warpRips.push({pos:n,dir:vsub(h,n),len:a*R.random(.1,.5)}),e.splice(t[0],t[t.length-1]-t[0]))}i=[]}}}let t=!0;return this.weft.forEach(e=>e.forEach((e,i)=>{const r=e.ps.filter(t=>!this.pointInRip(t)).length>0;if(r&&t||!r&&!t){let i=e.ps.filter(t=>null!=t)[0],a=vsub(e.ps[1],e.ps[0]);r?i.add(a):i.sub(a),this.weftRips.push({pos:i,dir:t?e.dir().mult(-1):e.dir()}),t=!t}})),this.weft.forEach(t=>t.forEach(t=>t.ps=t.ps.filter(t=>!this.pointInRip(t)))),this.hasRips=!0,this}async drawRips(){let t=0;for(const e of this.warpRips)await franzim(e.pos,e.dir,e.len),t++%10==0&&await timeout(0);let e=0;this.weftRips=this.weftRips.filter(t=>R.random_dec()<.7);for(const t of this.weftRips){let i=!1;for(const e of this.ripExtendMasks)e.hasWeftOn(t.pos)&&(i=!0);if(i)continue;let r=color(this.color);if(this.weft.forEach(e=>e.forEach(e=>e.ps.forEach(i=>{i&&vdist(i,t.pos)<10&&(r=e.getFinalColor())}))),r.setAlpha(50),R.random_dec()<.25){stroke(r);for(let e=0;e<R.random(1,5);e++)await tinyThread(t.pos.copy().mult(globalScale),R.random(3,10))}else{let e=[t.pos.copy(),t.pos.copy()];const i=t.dir.setMag(4*globalScale),a=R.random(6,12);for(let t=0;t<a;t++)i.rotate(R.random(-25,25)),e.push(e[e.length-1].copy().add(i));await thread(e,r,5,50)}e++%30==0&&await timeout(0)}}doAge(){floor(this.weft.length/2);this.weft.forEach((t,e)=>{for(let e=0;e<t.length;e++){const i=t[e].ps[0],r=1-dist(i.x,i.y,baseWidth/2,baseHeight/2)/(baseHeight/2);t[e].age=r*this.age/2,t[e].yellow=r*this.age/2}})}dropShadowOn(t){for(const e of t)this.lp.dropShadowOn(e)}foldedStitchings(t){t||(t=this.lp);const e=createGraphics(baseWidth,baseHeight);e.noStroke();const i=new LayoutPattern2(t.ps),r=R.random()<.5?[12]:[9,25];e.fill(255,100),i.ps=t.getOffset(0),i.crv().forEach(t=>e.circle(t.x,t.y,R.random(5)*initialThreadSize)),e.fill(255,30);for(const a of r)i.ps=t.getOffset(a+1),i.crv().forEach(t=>e.circle(t.x,t.y,R.random(5)*initialThreadSize));e.fill(0,30);for(const a of r)i.ps=t.getOffset(a),i.crv().forEach(t=>e.circle(t.x,t.y,R.random(7))*initialThreadSize);for(let a=0;a<r.length;a++)i.ps=t.getOffset(r[a]-12),i.crv().forEach((t,i)=>{const r=(sin(8*i)+1)/2;e.fill(255*r,7),e.circle(t.x,t.y,R.random(4,20)*initialThreadSize)});return this.weft.forEach(t=>{t.forEach(t=>{if(t.ps.length>0){const i=t.ps[0],r=e.get(i.x,i.y);alpha(r)>0&&(t.age=brightness(r)/360*(alpha(r)/255),t.yellow&&(t.yellow=0),t.darkness=.2-brightness(r)/360*(alpha(r)/255)/5)}})}),t.setStitches(stitchTypes.DOUBLE,r),this}}