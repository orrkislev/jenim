async function drawDot(t){allDots++,allDots%2e4==0&&await timeout(0),point(t.x,t.y)}function timeout(t){return new Promise(e=>setTimeout(e,t))}async function burn(t,e,i=7){blendMode(BURN),fill(30,30,90,i),noStroke(),circle(t.x,t.y,e*R.random(.4,1)),blendMode(BLEND)}async function dodge(t,e,i=7){blendMode(DODGE),fill(150,150,100,3),noStroke();for(let r=0;r<i;r++)circle(t.x+R.random(-e/2,e/2),t.y+R.random(-e/2,e/2),e*R.random(.4,1));blendMode(BLEND)}function getPointOnEllipse(t,e,i){return createVector(.5*t*cos(i),.5*e*sin(i))}function getEllipse(t,e,i=1,r=0,s=360){const a=[];for(let o=r;o<s;o+=i)a.push(getPointOnEllipse(t,e,o));return a}function toCrv(t){t.push(t[t.length-1]),t.splice(0,0,t[0]);const e=[];for(let i=0;i<t.length-3;i++){const r=t[i+1],s=t[i+2],a=p5.Vector.dist(r,s);for(let r=0;r<a;r++)x=curvePoint(t[i].x,t[i+1].x,t[i+2].x,t[i+3].x,r/a),y=curvePoint(t[i].y,t[i+1].y,t[i+2].y,t[i+3].y,r/a),e.push(createVector(x,y))}return e}function crvLength(t){l=0;for(let e=0;e<t.length-1;e++)l+=p5.Vector.dist(t[e],t[e+1]);return l}function placeOnCurve(t,e){let i=0;for(let r=0;r<t.length-1;r++)if(i+=sqrt((t[r].x-t[r+1].x)**2+(t[r].y-t[r+1].y)**2),i>=e)return t[r];return!1}function inCanvas(t){return t.x>0&&t.x<baseWidth&&t.y>0&&t.y<baseHeight}class Random{constructor(){this.usage=0,this.useA=!1;let t=function(t){let e=parseInt(t.substr(0,8),16),i=parseInt(t.substr(8,8),16),r=parseInt(t.substr(16,8),16),s=parseInt(t.substr(24,8),16);return function(){e|=0,i|=0,r|=0,s|=0;let t=(e+i|0)+s|0;return s=s+1|0,e=i^i>>>9,i=r+(r<<3)|0,r=r<<21|r>>>11,r=r+t|0,(t>>>0)/4294967296}};this.prngA=new t(tokenData.hash.substr(2,32)),this.prngB=new t(tokenData.hash.substr(34,32));for(let t=0;t<1e6;t+=2)this.prngA(),this.prngB()}random_dec(){return this.usage++,this.useA=!this.useA,this.useA?this.prngA():this.prngB()}random_num(t,e){return t+(e-t)*this.random_dec()}random_int(t,e){return Math.floor(this.random_num(t,e+1))}random_choice(t){return t[this.random_int(0,t.length-1)]}random(t=1,e=0){return this.random_num(t,e)}random_in(t){return this.random_num(t[0],t[1])}}let R=new Random;p5.Color.prototype.toRGB=function(){return color(red(this),green(this),blue(this),alpha(this))},Array.prototype.rotate=function(){return this.push(this.shift()),this[0]};const v=(t,e)=>createVector(t,e),v_rel=(t,e)=>createVector(t*baseWidth,e*baseHeight),vlerp=p5.Vector.lerp,vdist=p5.Vector.dist;vadd=p5.Vector.add,vsub=p5.Vector.sub;let allDots=0;warpSpacingMinMax=[.8,2],weftSpacingMinMax=[.8,1],startOffset=[2,1,0],patternTop=[2],patternBottom=[1];class Denim{constructor(t,e,i=.5){this.lp=t,this.color=e,this.visibleWhite=R.random(.5,1),this.darkness=R.random(.3),this.noiseScale=R.random(200,400),this.warpExtensions=[15,40],this.extendChance=.5,this.age=i,this.rotation=0,this.ripNoiseZ=R.random(1e3),this.ripThreshold=R.random(.18,.32),this.ripMin=R.random(30,70)*initialThreadSize,this.ripMax=R.random(this.ripMin,160)*initialThreadSize,this.ripExtendMasks=[]}rotate(t){return this.rotation=t,this}calc(){return this.ripThreshold+=.3*globalAge,this.age+=globalAge,this.ripMin-=30*globalAge,this.ripMax-=70*globalAge,this.warp||this.makeWarp(),this.weft||this.makeWeft(),this.trim(),this.unravel(),this.doAge(),this}async draw(t={}){threadSize=initialThreadSize,await this.drawWarp(),await this.drawWeft(),await this.lp.drawStitches(this),t.dontFringe||await this.extendWarps()}async finishDraw(){this.hasRips&&await this.drawRips()}makeWarp(){const t=this.lp.rotatedContainingSquare(this.rotation),{pos:e,w:i,h:r,rotation:s}=t.getDimension(),a=p5.Vector.fromAngle(radians(s)).setMag(i),o=a.copy().rotate(PI/2).normalize(),n=5*initialThreadSize,h=e.copy().add(o.copy().setMag(n).mult(-1)),l=h.copy().add(a).add(),p=15,c=Array(p).fill(0).map((t,e)=>vlerp(h,l,e/(p-1)));c.forEach(t=>t.add(o.copy().mult(R.random(-n,n)))),this.warp=[c];let d=!0;for(;d;){const t=this.warp[this.warp.length-1],e=t.map(t=>t.copy());e.forEach(t=>t.add(o.copy().mult(threadSize*R.random(warpSpacingMinMax[0],warpSpacingMinMax[1])))),this.warp.push(e),d=!1,e.forEach((t,e)=>{vdist(t,c[e])<r&&(d=!0)})}this.warp=this.warp.map(t=>toCrv(t))}async drawWarp(){let t=0;threadSize=initialThreadSize/2;for(const e of this.warp){const i=lerpColor(color(warpColors[0]),color(warpColors[1]),R.random_dec());await thread(e,i,5),t++%10==0&&await timeout(0)}}async extendWarps(){for(const t of this.warp){if(R.random_dec()<this.extendChance){const e=vsub(t[0],t[1]);await franzim(t[0],e,threadSize*R.random_in(this.warpExtensions))}if(R.random_dec()<this.extendChance){const e=vsub(t[t.length-1],t[t.length-2]);await franzim(t[t.length-1],e,threadSize*R.random_in(this.warpExtensions))}await timeout(0)}}makeWeft(){threadSize=initialThreadSize,this.weft=[{column:this.warp.map(t=>t[0]),threadSize:threadSize}];const t=crvLength(this.warp.reduce((t,e)=>crvLength(t)>crvLength(e)?t:e));for(let e=0;e<t;e+=threadSize*R.random_in(weftSpacingMinMax))this.weft.push({column:this.warp.map(t=>placeOnCurve(t,e)).filter(t=>0!=t),threadSize:threadSize}),threadSize=initialThreadSize*R.random(1,1.2);const e=color(this.color),i=lerpColor(e,color(255),this.visibleWhite);this.weft=this.weft.map(t=>{const r=[],s=[e,i];for(let t=0;t<startOffset[0]-1;t++)s.rotate();for(let e=startOffset.rotate();e<t.column.length;e+=patternBottom.rotate()){let i=t.column.slice(e,e+patternTop.rotate()+1);e+=patternTop[0];let a=s.rotate();a=lerpColor(a,color(0),noise(i[0].x/this.noiseScale,i[0].y/this.noiseScale)*this.darkness),r.push(new Loop(i,a,t.threadSize))}return r})}async drawWeft(){let t=0;for(const e of this.weft){for(const t of e)await t.draw();t++%10==0&&await timeout(0)}}hasWeftOn(t){for(const e of this.weft)for(const i of e)for(const e of i.ps)if(e&&vdist(t,e)<5)return i;return!1}trim(){this.warp=this.warp.map(t=>t.filter(t=>this.lp.pointInPattern(t))),this.warp=this.warp.filter(t=>t.length>1),this.weft=this.weft.map(t=>t.filter(t=>t.ps.filter(t=>this.lp.pointInPattern(t)).length>1)),this.warp=this.warp.map(t=>t.filter(t=>t.x>=.1*-baseWidth&&t.x<=1.1*baseWidth&&t.y>=.1*-baseHeight&&t.y<=1.1*baseHeight))}unravel(){this.weft.forEach(t=>{t.length>4&&(t[0].ps.forEach(t=>t.add(threadSize*R.random(-.3,.3),threadSize*R.random(-.3,.3))),t[t.length-1].ps.forEach(t=>t.add(threadSize*R.random(-.3,.3),threadSize*R.random(-.3,.3))))})}pointInRip(t){return noise(ripNoiseScale[0]*t.x/baseWidth,ripNoiseScale[1]*t.y/baseHeight,this.ripNoiseZ)<this.ripThreshold}makeRips(){this.warpRips=[],this.weftRips=[];for(let t=0;t<this.warp.length;t++){const e=this.warp[t];let i=[];if(0!=e.length)for(let t=0;t<200;t++){const r=e[floor(e.length*t/200)];if(this.pointInRip(r))i.push(t);else{if(i.length>2){const t=i.map(t=>floor(t*e.length/200)),r=t.map(t=>e[t]),s=crvLength(r),a=r[0].copy(),o=r[1].copy(),n=r[r.length-1].copy(),h=r[r.length-2].copy(),l=vsub(a,o).rotate(90);if(s>this.ripMin&&s<this.ripMax){let i=[];const r=ceil(s/10);for(let t=0;t<=r;t++){const e=vlerp(a,n,t/r),s=40*noise(e.x/50,e.y/50)-20;i.push(e.add(l.copy().setMag(s)))}i=toCrv(i),e.splice(t[0],t[t.length-1]-t[0],...i)}s>this.ripMax&&(this.warpRips.push({pos:a,dir:vsub(o,a),len:s*R.random(.1,.5)}),this.warpRips.push({pos:n,dir:vsub(h,n),len:s*R.random(.1,.5)}),e.splice(t[0],t[t.length-1]-t[0]))}i=[]}}}let t=!0;return this.weft.forEach(e=>e.forEach((e,i)=>{const r=e.ps.filter(t=>!this.pointInRip(t)).length>0;if(r&&t||!r&&!t){let i=e.ps.filter(t=>null!=t)[0],s=vsub(e.ps[1],e.ps[0]);r?i.add(s):i.sub(s),this.weftRips.push({pos:i,dir:t?e.dir().mult(-1):e.dir()}),t=!t}})),this.weft.forEach(t=>t.forEach(t=>t.ps=t.ps.filter(t=>!this.pointInRip(t)))),this.hasRips=!0,this}async drawRips(){let t=0;for(const e of this.warpRips)await franzim(e.pos,e.dir,e.len),t++%10==0&&await timeout(0);threadSize=initialThreadSize;let e=0;this.weftRips=this.weftRips.filter(t=>R.random_dec()<.7);for(const t of this.weftRips){let i=!1;for(const e of this.ripExtendMasks)e.hasWeftOn(t.pos)&&(i=!0);if(i)continue;let r=color(this.color);this.weft.forEach(e=>e.forEach(e=>e.ps.forEach(i=>{i&&vdist(i,t.pos)<10&&(r=e.getFinalColor())}))),r.setAlpha(50);let s=[t.pos.copy(),t.pos.copy()];const a=R.random_int(1,4);for(let i=1;i<4;i++){const o=t.dir.setMag(4*globalScale);for(let t=0;t<i*a;t++)o.rotate(R.random(-35,35)),s.push(s[s.length-1].copy().add(o));await thread(s,r,10,20),e++%30==0&&await timeout(0)}}}doAge(){floor(this.weft.length/2);this.weft.forEach((t,e)=>{for(let e=0;e<t.length;e++){const i=t[e].ps[0],r=1-dist(i.x,i.y,baseWidth/2,baseHeight/2)/(baseHeight/2);t[e].age=r*this.age/2,t[e].yellow=r*this.age/2}})}dropShadowOn(t){for(const e of t)this.lp.dropShadowOn(e)}foldedStitchings(t){t||(t=this.lp);const e=createGraphics(baseWidth,baseHeight);e.noStroke();const i=new LayoutPattern2(t.ps),r=R.random()<.5?[12]:[9,25];if(e.fill(0,20),i.crv().forEach(t=>e.circle(t.x,t.y,R.random(10)*initialThreadSize)),2==r.length){let r=0;i.ps=t.getOffset(18),i.crv().forEach((t,i)=>{r+=R.random(15);const s=(sin(r)+1)/2;e.fill(150*s,100),e.circle(t.x,t.y,R.random(4,25)*initialThreadSize)})}e.fill(0,20);for(const s of r)i.ps=t.getOffset(s),i.crv().forEach(t=>e.circle(t.x,t.y,R.random(7))*initialThreadSize);return this.weft.forEach(t=>{t.forEach(t=>{if(t.ps.length>0){const i=t.ps[0],r=e.get(i.x,i.y);alpha(r)>0&&(t.age=brightness(r)/360*(alpha(r)/255),t.yellow&&(t.yellow=0),t.darkness=.4-brightness(r)/360*(alpha(r)/255)*.4)}})}),t.setStitches(r),this}}