function initColorFunc(){let t=R.random_dec();if(t<.6)globalColorFunc=null;else{let t=[bleach_gradient,bleach_large,bleach_noise,strips,checkers,painters_camo,painters_pollock];specialWeave&&(t=[bleach_gradient,bleach_large,strips]),globalColorFunc=R.random_choice(t),globalColorFunc!=painters_pollock&&globalColorFunc!=painters_camo||initPainters()}}function applyColorFunc(t,e){if(e){const o=R.random(-35,35),r=R.random(-35,35);t.weft.forEach(t=>{t.forEach(t=>{if(t.ps.length>0){const a=t.ps[0];t.color=e(t.color,a.x+o,a.y+r)}})})}}function makeColor(t,e=360,o=360){colorMode(HSB,360);let r=color(t,e,o);return colorMode(RGB),r=r.toRGB(),r}function neighborColor(t,e=0,o=null,r=null){colorMode(HSB,360);const a=hue(t)+e,s=null!=o?map(saturation(t),0,100,0,360)+o:R.random(360),i=null!=r?brightness(t)+r:R.random(360);let l=color(a,s,i);return colorMode(RGB),l=l.toRGB(),l}async function franzim(t,e,o){franzimDirOffset||(franzimDirOffset=R.random(-45,45)),threadSize=.8*initialThreadSize,e.setMag(3*globalScale);let r=[t];for(let t=0;t<o/e.mag();t++){const t=noise(20*r[r.length-1].x/baseWidth,20*r[r.length-1].y/baseHeight),o=120*(t-.5);e.rotate(o/10+R.random(-5,5)),r.push(r[r.length-1].copy().add(e))}r=makeCurve(r);for(let t=0;t<r.length;t++)await burn(r[t].copy().add(6*t/r.length,6*t/r.length).mult(globalScale),this.threadSize*globalScale,7);await thread(r,color(R.random_choice(warpColors)),3,50),franzimDirOffset+=.1}async function thread(t,e,o=1,r=120){newPs=t.map(t=>t.copy().mult(globalScale)),noFill(),noStroke();let a=newPs.map(t=>t.copy());if(!(a.length<2||crvLength(a)<1)){newPs.length<10&&(a=makeCurve(newPs)),fill(e),a.forEach(t=>circle(t.x,t.y,threadSize*globalScale)),noFill(),strokeWeight(.2*threadSize*globalScale),e.setAlpha(r),stroke(e);for(let t=0;t<o;t++)for(let t=0;t<a.length;t++)await tinyThread(a[t])}}async function tinyThread(t,e=1){noFill(),beginShape(),curveVertex(t.x,t.y),curveVertex(t.x,t.y),curveVertex(t.x+threadSize*globalScale*cos(tinyThreadDir+=35)*e,t.y+threadSize*globalScale*sin(tinyThreadDir+=35)*e),curveVertex(t.x+threadSize*globalScale*sin(tinyThreadDir+=70)*e,t.y+threadSize*globalScale*cos(tinyThreadDir+=70)*e),curveVertex(t.x+threadSize*globalScale*cos(tinyThreadDir+=100)*e,t.y+threadSize*globalScale*sin(tinyThreadDir+=105)*e),endShape(),tinyThreadDir>1e4&&(tinyThreadDir=0)}const stitchTypes={SINGLE:0,DOUBLE:1,CROSS:2,ZIGZAG:3};class PatternShape{constructor(t){this.ps=t}draw(){beginShape(),this.ps.forEach(t=>vertex(t.x,t.y)),endShape(CLOSE)}center(){let t=v(0,0);return this.ps.forEach(e=>t.add(e)),t.div(this.ps.length),t}rotate(t){const e=this.center();this.rotateAround(e,t)}rotateAround(t,e){const o=this.ps.map(e=>e.copy().sub(t));o.forEach(t=>t.rotate(e)),o.forEach(e=>e.add(t)),this.ps=o}rotatedContainingSquare(t){const e=this.center();this.rotate(-t);const o=this.containingSquare();return o.rotateAround(e,t),this.rotate(t),o}containingSquare(){const t=this.ps.reduce((t,e)=>t.y<e.y?t:e).y,e=this.ps.reduce((t,e)=>t.y>e.y?t:e).y,o=this.ps.reduce((t,e)=>t.x<e.x?t:e).x,r=this.ps.reduce((t,e)=>t.x>e.x?t:e).x;return new SquarePatternShape(o,t,r-o,e-t)}makeCurve(){this.ps=this.getCurve()}getCurve(){let t=[];for(let e=0;e<this.ps.length;e++){const o=makeCurve([this.ps[e],this.ps[(e+1)%this.ps.length]]);t=t.concat(o.slice(0,o.length-1))}return t}goAlong(t){for(const e of this.ps)t(e)}async asyncGoAlong(t){for(const e of this.ps)await t(e)}fillet(t){const e=[];for(let o=0;o<this.ps.length;o++){const r=this.ps[o],a=this.ps[(o+1)%this.ps.length],s=this.ps[(o+2)%this.ps.length],i=p5.Vector.sub(a,r).setMag(t),l=p5.Vector.sub(a,s).setMag(t);e.push(p5.Vector.add(a,l)),e.push(p5.Vector.add(a,i))}return this.ps=e,this}}const p2i=(t,e,o)=>4*((round(t)-1/o)*o+(round(e)-1/o)*o*(round(baseWidth)*o));class LayoutPattern2 extends PatternShape{constructor(t){super(t)}makeGraphics(){this.graphics=createGraphics(baseWidth,baseHeight),this.graphics.beginShape(),this.ps.forEach(t=>this.graphics.vertex(t.x,t.y)),this.graphics.endShape(CLOSE),this.graphicsDensity=this.graphics.pixelDensity(),this.graphics.loadPixels()}pointInPattern(t){return this.graphics||this.makeGraphics(),alpha(this.graphics.get(t.x,t.y))>0}getOffset(t){let e=[...this.ps];return e.push(this.ps[0]),e=e.map((e,o)=>{const r=this.ps[(o+1)%this.ps.length],a=this.ps[(o+2)%this.ps.length],s=p5.Vector.sub(r,e),i=p5.Vector.sub(r,a);let l=i.angleBetween(s);return l<0&&(l+=360),i.rotate(l/2).setMag(t*initialThreadSize),p5.Vector.add(r,i)}),e}stitches(t,e,o,r=!1){const a=new LayoutPattern2(this.getOffset(t)),s=a.getCurve(),i=[];e*=initialThreadSize,o*=initialThreadSize;for(let t=0;t<crvLength(s)-e;t+=r?o*R.random(.9,1.2):o){const o=placeOnCurve(s,t);t+=r?e*R.random(.9,1.2):e;const a=placeOnCurve(s,t);o&&a&&i.push([o,a])}return i}dropShadowOn(t){const e=createGraphics(baseWidth,baseHeight);e.noStroke(),e.fill(0,5),e.beginShape(),this.getCurve().forEach(t=>e.vertex(t.x,t.y)),e.endShape(),this.getCurve().forEach(t=>e.circle(t.x+5,t.y+5,threadSize*R.random(10))),t.weft.forEach(t=>{t.forEach(t=>{if(t.ps.length>0){const o=t.ps[0],r=e.get(o.x,o.y);alpha(r)>0&&(t.darkness=.2-alpha(r)/255/5)}})})}setStitches(t,e){this.stitchType=t,this.stitchData=e}async drawStitches(t=null){if(!this.stitchType)return;let e=[];for(const t of this.stitchData)e=[...e,...this.stitches(t,7,6)];if(this.stitchType==stitchTypes.HANDMADE)for(const t of this.stitchData){e=this.stitches(t,6,8,!0);for(let t of e)t[0].add(R.random(-threadSize,threadSize)),t[1].add(R.random(-threadSize,threadSize))}for(let o of e){const e=t.hasWeftOn(o[0]);if(e){const t=new Loop(o,stitchColor,2*initialThreadSize).wiggle().shadow();t.age=e.age,await t.draw()}}}}class SquarePatternShape extends LayoutPattern2{constructor(t,e,o,r){super([v(t,e),v(t,e+r),v(t+o,e+r),v(t+o,e)]),this.rotation=0}rotateAround(t,e){this.rotation=e,super.rotateAround(t,e)}getDimension(){const t=this.ps[0],e=p5.Vector.dist(this.ps[0],this.ps[3]),o=p5.Vector.dist(this.ps[0],this.ps[1]);return{pos:t,w:e,h:o,rotation:this.rotation}}}const gold=["#a67c00","#bf9b30","#ffbf00","#ffcf40","#ffdc73"],natural=["#ede8d3","#fafaf7","#fcfcfc"],checkers=(t,e,o)=>{const r=120*initialThreadSize,a=60*initialThreadSize;return(e%r<a&&o%r<a||e%r>a&&o%r>a)&&(t=lerpColor(t,color(0),.3)),t},bleach_gradient=(t,e,o)=>(t=lerpColor(t,color(255),1-o/baseHeight),t),bleach_noise=(t,e,o)=>{const r=80*initialThreadSize,a=noise(e/r,o/r,R.random(.3));return a<.5&&(t=lerpColor(t,color(255),a+.5)),t};let bleachScale=null;const bleach_large=(t,e,o)=>(bleachScale||(bleachScale=R.random(20,100)*initialThreadSize),val=o/baseHeight,noise(e/bleachScale,o/bleachScale)<val&&(t=lerpColor(t,color(255),val)),t);let stripYSize;const strips=(t,e,o)=>(stripYSize||(stripYSize=R.random(3)),(e+floor(o/stripYSize))%(120*initialThreadSize)<60*initialThreadSize&&(t=lerpColor(t,color(255),.4)),t);let polockImage,paintersLayers=[];const initPainters=()=>{for(let t=0;t<2;t++)paintersLayers.push({s:R.random(300,600),val:R.random(.4,.6),z:R.random(10),color:makeColor(R.random(0,120),360,R.random(120,360))});if(globalColorFunc==painters_pollock){polockImage=createGraphics(baseWidth,baseHeight);for(let t=0;t<150;t++){polockImage.fill(R.random_choice([color(0),color(255)])),polockImage.noStroke();const t=v(R.random(baseWidth),R.random(baseHeight)),e=v(R.random(-.1,.1),R.random(-.1,.1)),o=R.random(50,250);let r=R.random(100);for(let a=0;a<o;a++){const s=noise(r,10)**2*map(a,0,o,90,10);r+=.02,polockImage.circle(t.x,t.y,s),t.add(e),e.rotate(R.random(-4,4)),e.setMag(1.04*e.mag())}}}},painters_camo=(t,e,o)=>{for(let r=paintersLayers.length-1;r>=0;r--){const a=paintersLayers[r];noise(e/a.s,o/a.s,a.z)<a.val&&(t=lerpColor(t,a.color,.7))}return t},painters_grad=(t,e,o)=>{for(let r=paintersLayers.length-1;r>=0;r--){const a=paintersLayers[r];t=lerpColor(t,a.color,noise(e/a.s,o/a.s,a.z)*(1-o/baseHeight))}return t},painters_pollock=(t,e,o)=>{if(polockImage){const r=polockImage.get(e,o);if(r[3]>0)return lerpColor(t,color(r),.7)}return t};let globalColorFunc=null;const initBaseColor=()=>{const t=R.random_dec();t<.7?(stitchColor=color("orange"),denimColor=makeColor(R.random(200,250),360,R.random(180,360)),patchStitchColor=R.random_choice([color(255,0,0),color(0),color(255)]),print("indigo")):t<.8?(stitchColor=color(255),denimColor=makeColor(0,0,0),patchStitchColor=color(255),print("black")):(stitchColor=color(255),denimColor=makeColor(R.random(0,70),R.random(200,360),R.random(100,250)),patchStitchColor=color(0),print("colorful"))};let franzimDirOffset;class Loop{constructor(t,e,o){this.threadSize=o||threadSize,this.originalColor=e,this.color=e,this.ps=t,this.age=0,this.darkness=0}wiggle(){const t=this.ps[0],e=this.ps[this.ps.length-1],o=p5.Vector.add(t,e).div(2),r=p5.Vector.sub(t,e).rotate(90).normalize().mult(p5.Vector.dist(t,e)*R.random(-.05,.05));return o.add(r),this.ps=[t,o,e],this}shadow(t=!0){return this.withShadow=t,this}getFinalColor(){let t=this.color;return this.age&&(t=lerpColor(t,color(R.random_choice(natural)),this.age)),this.yellow&&(t=lerpColor(t,color("#ebe1a2"),this.yellow)),0!=this.darkness&&(t=neighborColor(t,0,.5*this.darkness*360,-.5*this.darkness*360)),t}async draw(){if(!(this.ps.length<=1)){if(this.withShadow)for(const t of makeCurve(this.ps))await burn(t.copy().add(2,0).mult(globalScale),this.threadSize*globalScale*R.random(1,3),10);this.age&&(this.color=lerpColor(this.color,color(R.random_choice(natural)),this.age)),this.yellow&&(this.color=lerpColor(this.color,color("#ebe1a2"),this.yellow)),0!=this.darkness&&(this.color=neighborColor(this.color,0,.5*this.darkness*360,-.5*this.darkness*360)),threadSize=this.threadSize,await thread(this.ps,this.color,3)}}dir(){return this.ps.length<=1?v(0,0):p5.Vector.sub(this.ps[this.ps.length-1],this.ps[0])}}let t1=0,tinyThreadDir=0;